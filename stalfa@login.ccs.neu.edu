#!/usr/bin/env python3

import json
import time
import threading
import queue
import asyncio
import sys
from config import Config
from connection import ClientConnection
from messages import *

DELAY = 3           # client timeout delay (in seconds)
NUM_SERVERS = 0     # total number of servers
CHOOSE_RANDOM_LEADER = True # flag telling client to randomly choose new leader
SEND_NEW = True         # flag telling client to send a new instruction
SEND_SUCCESS = False    # flag telling client that last message was received by leader


class Client:
    def __init__(self):
        self.leader = 0
        self.msgId = 0
        self.sendQ = queue.Queue()
        self.recQ = queue.Queue()
        self._conn = ClientConnection()
        self._loop = asyncio.get_event_loop()
        self._id = self._conn.client_id
    
    def find_leader(self):
        return self.leader

    def put(self, key, value):
        # push put message onto sendQ
        return None

    def get (self, key):
        # push get message onto sendQ
        return None

    async def tryInstruction(self):
        print("in sendInstruction") #debug
        sendHandle = asyncio.Handle()
        while True:
            await asyncio.sleep(1)
            if not self.sendQ.empty() and SEND_NEW:
                print("sendQ not empty") #debug
                msg_to_server = self.sendQ.get()
                msg_to_server.handle(self) #debug
                sendHandle = self._loop.call_later(DELAY, sendInstruction, msg_to_server)
                SEND_NEW = False
            if SEND_SUCCESS == True:
                SEND_SUCCESS = False
                sendHandle.cancel()
                SEND_NEW = True

    def sendInstruction(self, instruction):
        if CHOOSE_RANDOM_LEADER:
            self.leader = (self.leader + 1) % NUM_SERVERS
        self.msgId = self.msgId + 1
        instruction.id = self.msgId
        # send instruction to current leader
        pass

    def test_handler(self, msg):
        print(self._id, ':', msg)

    def get_reply_handler(self, msg):
        pass

    def get_handler(self, msg):
        print(self._id, ':', msg)

    def put_handler(self, msg):
        print(self._id, ": put(", msg.key, ',', msg.value, ')')

    def put_reply_handler(self, msg):
        pass

    async def generator(self, loop, stream):
        reader = asyncio.StreamReader(loop=loop)
        reader_protocol = asyncio.StreamReaderProtocol(reader)
        await loop.connect_read_pipe(lambda:reader_protocol, stream)
        while True:
            line = await reader.readline()
            if not line:
                break
            yield line.decode()

    async def inputInstruction(self):
        print("in input instruction") # debug
        async for line in Client.generator(self, self._loop, sys.stdin):
            input = line.split()
            if input[0] == "put":
                if len(input) != 3:
                    print("bad instruction")
                else:
                    msg = Put(input[1], input[2])
                    msg.handle(self) #debug
                    self.sendQ.put(msg)
            elif input[0] == 'get':
                if len(input) != 2:
                    print("bad instruction")
                else: 
                    msg = Get(input[1])
                    msg.handle(self) #debug
                    self.sendQ.put(msg)
            else: print("bad instruction")


    async def server_handler(self):
        print("I'm Client", self._id)
        while True:
            msg = await self._conn.receive_message_from_server()
            msg.handle(self) #debug
            if msg.notleader == False and msg.id == self.msgId:
                SEND_SUCCESS = True
            if msg.notleader == True and msg.id == self.msgId and SendSuccess == False:
                CHOOSE_RANDOM_LEADER = False
                self.leader = msg.leaderID

    def run(self):
        with self._conn:
            self._loop.create_task(Client.server_handler(self))
            self._loop.create_task(Client.tryInstruction(self))         
            self._loop.create_task(Client.inputInstruction(self))
            self._loop.run_forever()
        pending = [t for t in asyncio.Task.all_tasks()]
        for t in pending:
            t.cancel()
            with suppress(asyncio.CancelledError):
                self._loop.run_until_complete(t)
        self._loop.close()



# program is started with call to 
# python3 client.py --servers=<total number of servers>

if __name__ == "__main__":
    NUM_SERVERS = argv.servers
    client = Client()
    client.run()